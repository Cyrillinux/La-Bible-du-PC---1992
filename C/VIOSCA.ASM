;**********************************************************************;
;*                            V I O S C A                             *;
;*--------------------------------------------------------------------*;
;*    Fonction       : Fournit une fonction Ö intÇgrer dans un        *;
;*                     programme C et servant Ö dÇterminer le type    *;
;*                     des deux adaptateurs vidÇo installÇs.          *;
;*--------------------------------------------------------------------*;
;*    Auteur       : MICHAEL TISCHER                                  *;
;*    DÇveloppÇ le : 02.10.1988                                       *;
;*    Derniäre MAJ : 14.02.1992                                       *;
;*--------------------------------------------------------------------*;
;*    Assemblage   : MASM VIOSCA;                                     *;
;*                     ... puis Çdition de liens avec VIOSC.C         *;
;**********************************************************************;

;== Constantes pour la structure VIOS ==================================

                                      ;-- Constantes pour la carte vidÇo
NO_VIOS    = 0                                      ; Pas de carte vidÇo
VGA        = 1                                               ; Carte VGA
EGA        = 2                                               ; Carte EGA
MDA        = 3                              ; Monochrome Display Adapter
HGC        = 4                                  ; Hercules Graphics Card
CGA        = 5                                  ; Color Graphics Adapter
                                           ; Constantes pour le moniteur
NO_MON     = 0                                         ; Pas de moniteur
MONO       = 1                                     ; Moniteur monochrome
COLOR      = 2                                        ; Moniteur couleur
EGA_HIRES  = 3                  ; Moniteur haute rÇsolution ou Multisync
ANAL_MONO  = 4                          ; Moniteur analogique monochrome
ANAL_COLOR = 5                             ; Moniteur couleur analogique
; == DÇclarations de segment pour le programme C =======================

IGROUP group _text                  ; Regroupement segments de programme
DGROUP group const,_bss,  _data       ; Regroupement segments de donnÇes
       assume CS:IGROUP, DS:DGROUP, ES:DGROUP, SS:DGROUP

CONST  segment word public 'CONST'              ; Segment des constantes
CONST  ends                                         ; pour lecture seule

_BSS   segment word public 'BSS'                 ; Segment des variables
_BSS   ends                                 ; statiques non initialisÇes

_DATA  segment word public 'DATA'                   ; Segment de donnÇes

vios_tab   equ this byte

      ;-- table de conversion traitant le rÇsultat retournÇ par l'option
                              ;-- 00h de la fonction 1Ah du BIOS VGA----

           db NO_VIOS, NO_MON                       ; Pas de carte vidÇo
           db MDA    , MONO          ; Carte MDA sur moniteur monochrome
           db CGA    , COLOR            ; Carte CGA sur moniteur couleur
           db ?      , ?                            ; Code 3 non utilisÇ
           db EGA    , EGA_HIRES                 ; Carte EGA/moniteur HR
           db EGA    , MONO          ; Carte EGA sur moniteur monochrome
           db ?      , ?                            ; Code 6 non utilisÇ
           db VGA    , ANAL_MONO    ; Carte VGA/moniteur mono analogique
           db VGA    , ANAL_COLOR    ; Carte VGA/moniteur couleur analog

ega_dips   equ this byte

             ;-- Table de conversion pour traiter les micro-commutateurs
                                                 ;-- DIP de la carte EGA

           db COLOR, EGA_HIRES, MONO
           db COLOR, EGA_HIRES, MONO

_DATA  ends

; == Programme =========================================================

_TEXT  segment byte public 'CODE'                 ; Segment de programme

public     _get_vios

;-----------------------------------------------------------------------
;-- GET_VIOS: DÇtermine le type des cartes vidÇo installÇes ------------
;-- Appel en C   : void get_vios( struct vios *vp );
;-- DÇclaration  : struct vios { BYTE carte, monitor; };
;-- Valeur retournÇe : Aucune
;-- Infos        : Dans cet exemple, la fonction est conáue pour àtre
;--                intÇgrÇe dans le modäle SMALL


_get_vios  proc near

sframe     struc                      ; Structure pour accÇder Ö la pile
cga_possi  db ?                                        ; Variable locale
ega_possi  db ?                                                ;       "
mono_possi db ?                                                ;       "
bptr       dw ?                                              ; Reáoit BP
ret_adr    dw ?                         ; Adresse de retour Ö l'appelant
vp         dw ?                    ; Pointeur sur la 1äre structure VIOS
sframe     ends                                    ; Fin de la structure

frame      equ [ bp - cga_possi ]             ; ElÇments de la structure

           push bp                           ; Sauvegarde BP sur la pile
           sub  sp,3                  ; Place pour les variables locales
           mov  bp,sp                             ; Transfäre SP dans BP
           push di                                ; Sauve DI sur la pile

           mov  frame.cga_possi,1                        ; Peut àtre CGA
           mov  frame.ega_possi,1                        ; Peut àtre EGA
           mov  frame.mono_possi,1                ; Peut àtre MDA ou HGC

           mov  di,frame.vp         ; Recherche l'offset de la structure
           mov  word ptr [di],NO_VIOS              ; Aucun systäme vidÇo
           mov  word ptr [di+2],NO_VIOS          ; trouvÇ pour le moment

           call test_vga                            ; Teste si carte VGA
           cmp  frame.ega_possi,0          ; Carte EGA encore possible ?
           je  gv1                          ; NON --> passer au test CGA

           call test_ega                            ; Teste si carte EGA
gv1:       cmp  frame.cga_possi,0          ; Carte CGA encore possible ?
           je   gv2                   ; NON --> passe au test MDA et HGC
           call test_cga                            ; Teste si carte CGA
gv2:       cmp  frame.mono_possi,0  ; Carte MDA ou HGC encore possible ?
           je   gv3                             ; NON --> Tests terminÇs

           call test_mono                    ; Teste si carte MDA et HGC


           ;-- DÇtermine la carte vidÇo active -------------------------

gv3:       cmp  byte ptr [di],VGA               ; Carte VGA identifiÇe ?
           je   gvi_end              ; OUI, carte active dÇjÖ identifiÇe
           cmp  byte ptr [di+2],VGA      ; Carte VGA= systäme secondaire
           je   gvi_end              ; OUI, carte active dÇjÖ identifiÇe

           mov  ah,0Fh             ; DÇtermine le mode vidÇo courant par
           int  10h                               ; l'interruption vidÇo

           and  al,7           ; Seuls les modes 0 Ö 7 sont intÇressants
           cmp  al,7                         ; Carte monochrome active ?
           jne  gv4                            ; Non, en mode CGA ou EGA
           ;-- La carte MDA, HGC ou EGA (mono) est active --------------

           cmp  byte ptr [di+1],MONO                     ; Moniteur mono
           je   gvi_end                             ; OUI, ordre correct
           jmp  short echange                   ; NON, intervertir ordre

           ;-- Une carte CGA ou EGA est active -------------------------

gv4:       cmp  byte ptr [di+1],MONO   ; Moniteur mono ds 1äre structure
           jne  gvi_end                             ; NON, ordre correct

echange:   mov  ax,[di]               ; contenu de la premiäre structure
           xchg ax,[di+2]               ; Echange avec seconde structure
           mov  [di],ax

gvi_end:   pop  di                                ; Retire DI de la pile
           add  sp,3          ; Elimine les variables locales de la pile
           pop  bp                                ; Retire BP de la pile
           ret                                   ; Retour au programme C

_get_vios  endp

;-----------------------------------------------------------------------
;-- TEST_VGA: DÇtermine si une carte VGA est installÇe

test_vga   proc near

           mov  ax,1a00h       ; Appelle l'option 00h de la fonction 1Ah
           int  10h                                            ; du BIOS
           cmp  al,1ah                            ; Fonction supportÇe ?
           jne  tvga_end                    ; NON --> Termine la routine

          ;-- La fonction est supportÇe , BL contient maintenant le code
          ;-- du systäme vidÇo actif, BH celui du systäme non actif-----

           mov  cx,bx                        ; Range le rÇsultat dans CX
           xor  bh,bh                                       ; Met BH Ö 0
           or   ch,ch                          ; Un seul systäme vidÇo ?
           je   tvga_1                 ; OUI --> Code du premier systäme

          ;-- Convertit le code du second systäme ----------------------

           mov  bl,ch                     ; Code du second systäme en BL
           add  bl,bl                   ; Calcule l'offset dans la table
           mov  ax,offset DGROUP:vios_tab[bx]       ; Code dans la table
           mov  [di+2],ax           ; stocke dans la structure appelante
           mov  bl,cl       ; Remet dans BL les codes du premier systäme

          ;-- Convertit le code du premier systäme ---------------------

tvga_1:    add  bl,bl                   ; Calcule l'offset dans la table
           mov  ax,offset DGROUP:vios_tab[bx]       ; Code dans la table
           mov  [di],ax             ; stocke dans la structure appelante

           mov  frame.cga_possi,0     ; Le test CGA n'a plus lieu d'àtre
           mov  frame.ega_possi,0                 ; Le test EGA non plus
           mov  frame.mono_possi,0                 ; Reste Ö tester MONO

           mov  bx,di                   ; Adresse de la structure active
           cmp  byte ptr [bx],MDA       ; Systäme monochrome identifiÇ ?
           je   do_tmono                 ; OUI --> Effectue test MDA/HGC

           add  bx,2                  ; Adresse de la structure inactive
           cmp  byte ptr [bx],MDA       ; Systäme monochrome identifiÇ ?
           jne  tvga_end                        ; NON termine la routine

do_tmono:  mov  word ptr [bx],0        ; Simule la non-identification du
                                                               ; systäme
           mov  frame.mono_possi,1          ; ExÇcute le test monochrome

tvga_end:  ret                            ; Retour au programme appelant

test_vga   endp


;-----------------------------------------------------------------------
;-- TEST_EGA: DÇtermine si une carte EGA est installÇe

test_ega   proc near

           mov  ah,12h                                    ; Fonction 12h
           mov  bl,10h                                      ; Option 10h
           int  10h                                ; Appelle le BIOS EGA
           cmp  bl,10h                            ; Fonction supportÇe ?
           je   tega_end                    ; NON --> Termine la routine

         ;-- La fonction est supportÇe , CL contient maintenant --------
         ;-- la position des micro-commutateurs DIP de la carte EGA ----

           mov  al,cl                           ; Commutateurs DIP en AL
           shr  al,1              ; DÇcale d'une position vers la droite
           mov  bx,offset DGROUP:ega_dips           ; Offset de la table
           xlat                           ; ElÇment AL de la table en AL
           mov  ah,al                           ; Type de moniteur en AH
           mov  al,EGA                             ; C'est une carte EGA
           call trouve             ; Inscrit les donnÇes dans le vecteur

           cmp  ah,MONO              ; Connexion sur  Çcran monochrome ?
           je   is_mono                          ; OUI --> ni MDA ou HGC

           mov  frame.cga_possi,0                 ; Carte CGA impossible
           jmp  short tega_end                     ; Terminer la routine

is_mono:   mov  frame.mono_possi,0       ; carte EGA est sur un moniteur
                                  ; monochrome, ni MDA ni HGC ne peuvent
                                                       ; àtre installÇes

tega_end:  ret                            ; Retour au programme appelant

test_ega   endp

;-----------------------------------------------------------------------
;-- TEST_CGA: DÇtermine si une carte CGA est installÇe

test_cga   proc near

           mov  dx,3D4h      ; Adresse de port du registre CRTC pour CGA
           call test_6845              ; Teste si 6845 CRTC est installÇ
           jc   tega_end                       ; NON --> Termine le test
           mov  al,CGA                          ; OUI, CGA est installÇe
           mov  ah,COLOR         ; Toujours un moniteur couleur avec CGA
           jmp  trouve             ; Inscrit les donnÇes dans le vecteur

test_cga   endp

;-----------------------------------------------------------------------
;-- TEST_MONO: Teste la prÇsence d'une carte MDA ou HGC

test_mono  proc near

           mov  dx,3B4h        ; Adr. de port du registre CRTC pour MONO
           call test_6845              ; Teste si 6845 CRTC est installÇ
           jc   tega_end                       ; NON --> Termine le test

           ;-- Une carte d'Çcran monochrome est installÇe --------------
           ;-- Le test suivant fait la distinction entre MDA et HGC ----

           mov  dl,0BAh                       ; Port d'Çtat MONO en 3BAh
           in   al,dx                             ; Teste le port d'Çtat
           and  al,80h                           ; Ne garde que le bit 7
           mov  ah,al                              ; et le range dans AH

           ;-- Si le contenu du bit 7 du port d'Çtat est modifiÇ au ----
           ;-- cours de l'un des tests suivants, c'est qu'il s'agit ----
           ;-- d'une carte HGC                                      ----

           mov  cx,8000h                   ; 32768 itÇrations au maximum
test_hgc:  in   al,dx                             ; Teste le port d'Çtat
           and  al,80h                           ; Ne garde que le bit 7
           cmp  al,ah                 ; Son contenu a-t-il ÇtÇ modifiÇ ?
           jne  is_hgc               ; Bit 7 = 1 --> c'est une carte HGC
           loop test_hgc                            ; Poursuit la boucle

           mov  al,MDA            ; Le bit 7!= 1 --> c'est une carte MDA
           jmp  set_mono                           ; Fixe les paramätres

is_hgc:    mov  al,HGC   ; Le bit 7 est devenu 1 --> c'est une carte HGC
set_mono:  mov  ah,MONO            ; MDA et HGC seulement sur Çcran MONO
           jmp  trouve                             ; Fixe les paramätres

test_mono  endp


;-- TEST_6845: retourne un indicateur de retenue Ö 1 si aucun 6845
;--            ne figure Ö l'adresse de port en DX

test_6845  proc near

           mov  al,0Eh                          ; Appelle le registre 14
           out  dx,al      ; N¯ registre dans le registre d'adresse CRTC
           inc  dx          ; DX maintenant sur registre de donnÇes CRTC

           in   al,dx              ; Recherche le contenu du registre 14
           mov  ah,al                                ; et le range en AH

           mov  al,4Fh                          ; Ecrit dans le registre
           out  dx,al                            ; une valeur quelconque

           mov  cx,100             ; Petite boucle d'attente pour que le
wait:      loop wait                                ; 6845 puisse rÇagir

           in   al,dx                  ; Relit le contenu du registre 14
           xchg al,ah                             ; Intervertit AH et AL
           out  dx,al                       ; Restaure l'ancienne valeur

           cmp  ah,4Fh             ; La valeur Çcrite a-t-elle ÇtÇ lue ?
           je   t6845_end                      ; OUI --> Termine le test

           stc                 ; NON --> Met Ö 1 l'indicateur de retenue

t6845_end: ret                                     ; Retour Ö l'appelant

test_6845  endp

;-----------------------------------------------------------------------
;-- TROUVE : enregistre dans le vecteur vidÇo le type de carte vidÇo
;--          (en AL) et le type de moniteur (en AH)

trouve   proc near

           mov bx,di                    ; Adresse de la structure active
           cmp word ptr [bx],0                          ; systäme vidÇo?
           je  set_data       ; NON --> DonnÇes dans la structure active

           add bx,2            ; OUI, adresse de la structure dÇsactivÇe

set_data:  mov [bx],ax             ; Place les donnÇes dans la structure
           ret                            ; Retour au programme appelant

trouve   endp

;-----------------------------------------------------------------------

_text      ends                                 ; Fin du segment de code
           end                                        ; Fin du programme

